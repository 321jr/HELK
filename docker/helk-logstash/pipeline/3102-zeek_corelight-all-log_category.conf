# HELK Zeek and Corelight set event_log_category_type and implied protocol
# HELK build Stage: Alpha
# Author: Nate Guagenti (@neu5ron)
# License: GPL-3.0

filter {
  if [event_log_type] == "zeek" {
    # Ordered by most likely/common (make a 1/1000000000000 faster)

    # Network Protocols (network-protocols)
    if [event_sub_type] in [ "conn", "conn_long", "dce_rpc", "dhcp", "dnp3", "dns", "ftp", "gquic", "http", "imap", "irc", "kerberos", "modbus", "modbus_register_change", "mqtt_connect", "mqtt_publish", "mqtt_subscribe", "mysql", "ntlm", "ntp", "pop3", "radius", "rdp", "rfb", "sip", "smb_cmd", "smb_files", "smb_mapping", "smtp", "smtp_links", "snmp", "socks", "ssh", "ssl", "syslog", "tunnel" ] {

      mutate {
        add_field => {
          "event_log_category_type" => "network-protocols"
          "[@metadata][index_name]" => "logs-network-zeek"
        }
      }

      # If network_protocol does not exist already, lets try to determine what it will be
      if ![network_protocol] {

        if [event_sub_type] in [ "dhcp", "gquic", "ntp", "radius", "sip", "snmp" ] {
          mutate {
            add_field => {
              "etl_info_tags" => "inferred the field 'network_protocol' as udp"
              "network_protocol" => "udp"
            }
          }
        }
        #TODO: although uncommon, there is SMB udp I imagine zeek/corelight will set the proto thereafter, but in case not - then revisit
        else {
          mutate {
            add_field => {
              "network_protocol" => "tcp"
              "etl_info_tags" => "inferred the field 'network_protocol' as tcp"
            }
          }
        }

      }

    }

    # Files
    else if [event_sub_type] in [ "files", "ocsp", "pe", "x509" ] {
      mutate {
        add_field => {
          "event_log_category_type" => "files"
          "[@metadata][index_name]" => "logs-network-zeek"
        }
      }
    }

    # Miscellaneous
    else if [event_sub_type] in [ "barnyard2", "dpd", "unified2", "weird", "weird_stats" ] {
      mutate {
        add_field => {
          "event_log_category_type" => "miscellaneous"
          "[@metadata][index_name]" => "logs-network-zeek"
        }
      }
    }

    # Diagnostics
    else if [event_sub_type] in [ "broker", "capture_loss", "cluster", "communication", "config", "loaded_scripts", "packet_filter", "print", "prof", "reporter", "stats", "stderr", "stdout" ] {
      mutate {
        add_field => {
          "event_log_category_type" => "diagnostics"
          "[@metadata][index_name]" => "metrics-logs-zeek-diagnostics"
        }
      }
    }

    # Detection
    else if [event_sub_type] in [ "intel", "notice", "notice_alarm", "signatures", "traceroute" ] {
      mutate {
        add_field => {
          "event_log_category_type" => "detection"
        }
      }
    }

    # Netcontrol
    else if [event_sub_type] in [ "netcontrol", "netcontrol_catch_release", "netcontrol_drop", "netcontrol_shunt", "openflow" ] {
      mutate {
        add_field => {
          "event_log_category_type" => "netcontrol"
          "[@metadata][index_name]" => "metrics-logs-zeek"
        }
      }
    }

    # Parser for log not yet written
    else {
      mutate {
        add_field => {
          "event_log_category_type" => "unknown"
          "etl_info_tags" => "unknown zeek 'event_log_category_type'"
          "[@metadata][index_name]" => "logs-network-zeek"
        }
        #TODO: eventually make unparsed logs go into something like 'logs-network-zeek-unknown'
      }
    }

  }
}
