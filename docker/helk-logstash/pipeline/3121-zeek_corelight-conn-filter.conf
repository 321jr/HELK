# HELK Zeek and Corelight HTTP log
# HELK build Stage: Alpha
# Author: Nate Guagenti (@neu5ron)
# License: GPL-3.0
  
filter {
  if [event_type] == "zeek" and [event_sub_type] in [ "conn", "conn_long" ] {

    mutate {
      rename => {
        "conn_state" => "network_connection_state"
        "duration" => "event_duration"
        "history" => "network_connection_history"
        "id.orig_h_name.src" => "zeek_meta_src_ip_addr_source"
        "id.orig_h_name.vals" => "zeek_meta_src_ip_addr_host_name"
        "id.resp_h_name.src" => "zeek_meta_dst_ip_addr_source"
        "id.resp_h_name.vals" => "zeek_meta_dst_ip_addr_host_name"
        "local_orig" => "zeek_conn_local_src"
        "local_resp" => "zeek_conn_local_dst"
        "missed_bytes" => "network_missed_bytes"
        "orig_bytes" => "src_bytes"
        "orig_cc" => "zeek_orig_cc"
        "orig_ip_bytes" => "src_ip_bytes"
        "orig_l2_addr" => "src_mac"
        "orig_pkts" => "src_packets"
        "resp_bytes" => "dst_bytes"
        "resp_cc" => "zeek_resp_cc"
        "resp_ip_bytes" => "dst_ip_bytes"
        "resp_l2_addr" => "dst_mac"
        "resp_pkts" => "dst_packets"
        "service" => "network_application"
      }
      add_field => {
        "etl_pipeline" => "zeek-conn-main"
      }
    }

    # As of 2.6 this field is no longer empty, see 2.6 notes:
    # """
    # The "tunnel_parents" field of conn.log is now marked &optional, so, in the default configuration of logs,
    # this field will show "-"  instead of "(empty)" for connections that lack any tunneling.
    # """
    if [tunnel_parents] {
      ruby {
        code => "
          zeek_id_tunnel_parents = event.get('tunnel_parents')
          if !zeek_id_tunnel_parents.empty?
            event.set('zeek_id_tunnel_parents', zeek_id_tunnel_parents)
          end
        "
        add_field => { "etl_pipeline" => "zeek-tunnel_parents" }
        remove_field => [ "tunnel_parents" ]
        tag_on_exception =>  "_rubyexception-zeek-tunnel_parents"
      }
    }

    # Connection History & Connection State enrichment
    if [network_connection_history] {
      ruby {
        code => "
          hist = event.get('[network_connection_history]')
          hist_dict = {
            '^' => 'connection direction was flipped by Zeekâ€™s heuristic',
            'a' => 'pure ACK',
            'c' => 'packet with a bad checksum',
            'd' => 'packet with payload data',
            'f' => 'packet with FIN bit set',
            'g' => 'a content gap',
            'h' => 'a SYN+ACK handshake',
            'i' => 'inconsistent packet (e.g. FIN+RST bits set)',
            'q' => 'multi-flag packet (SYN+FIN or SYN+RST bits set)',
            'r' => 'packet with RST bit set',
            's' => 'SYN with out ACK set',
            't' => 'packet with retransmitted payload',
            'w' => 'packet with a zero window advertisement'
          }
          hist = hist.split('')
          hist = hist.uniq
          hist_client = ''
          hist_client_full = ''
          hist_server = ''
          hist_server_full = ''
          hist_full = ''
          for hist_value in hist
            if hist_value == hist_value.upcase
              dict_hist_full = hist_dict[hist_value.downcase]
              hist_client_full = hist_client_full + dict_hist_full + '. '
              hist_client = hist_client + hist_value
              hist_full = hist_full + dict_hist_full + '. '
            else
              dict_hist_full = hist_dict[hist_value]
              hist_server_full = hist_server_full + dict_hist_full + '. '
              hist_server = hist_server + hist_value
              hist_full = hist_full + dict_hist_full + '. '
            end
          end
          if !hist_client.empty?
            event.set('[src_network_connection_history]', hist_client)
            event.set('[src_network_connection_history_detailed]', hist_client_full)
          end
          if !hist_server.empty?
            event.set('[dst_network_connection_history]', hist_server)
            event.set('[dst_network_connection_history_detailed]', hist_server_full)
          end
          event.set('[network_connection_history_detailed]', hist_full)
        "
        tag_on_exception => "_rubyexception-zeek-network_connection_history_detailed"
      }
    }

    translate {
      field => "network_connection_state"
      destination => "network_connection_state_detailed"
      dictionary => [
        "S0", "Connection attempt seen, no reply",
        "S1", "Connection established, not terminated",
        "S2", "Connection established and close attempt by source seen (but no reply from destination)",
        "S3", "Connection established and close attempt by destination seen (but no reply from source)",
        "SF", "Normal SYN/FIN completion",
        "REJ", "Connection attempt rejected",
        "RSTO", "Connection established, source aborted (sent a RST)",
        "RSTR", "Established, destination aborted",
        "RSTOS0", "Source sent a SYN followed by a RST, never saw a SYN-ACK from the destination",
        "RSTRH", "Destination sent a SYN ACK followed by a RST, never saw a SYN from the (purported) source",
        "SH", "Source sent a SYN followed by a FIN, never saw a SYN ACK from the destination (ie: connection was half open)",
        "SHR", "Destination sent a SYN ACK followed by a FIN, never saw a SYN from the source",
        "OTH", "No SYN seen, just midstream traffic (a partial connection that was not later closed)"
      ]
    }

    # Add IP bytes so we can get totals
    if [src_ip_bytes] {
      ruby {
        code => "
          src = event.get('[src_ip_bytes]')
          dst = event.get('[dst_ip_bytes]')
          total = src + dst
          event.set('[network_ip_bytes]', total)
        "
        tag_on_exception => "_rubyexception-zeek-network_ip_bytes"
      }
    }
    # Add bytes so we can get totals
    if [src_bytes] {
      ruby {
        code => "
          src = event.get('[src_bytes]')
          dst = event.get('[dst_bytes]')
          # Destination/Server bytes may not always exist, ie: broadcast
          if !dst.nil?
            total = src + dst
          else
            total = src
          end
          event.set('[network_bytes]', total)
        "
        tag_on_exception => "_rubyexception-zeek-network_bytes"
      }
    }
    # Add packets so we can get totals
    if [src_packets] {
      ruby {
        code => "
          src = event.get('[src_packets]')
          dst = event.get('[dst_packets]')
          total = src + dst
          event.set('[network_packets]', total)
        "
        tag_on_exception => "_rubyexception-zeek-network_packets"
      }
    }

  }
}