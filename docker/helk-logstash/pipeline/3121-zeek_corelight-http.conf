# HELK Zeek and Corelight HTTP log
# HELK build Stage: Alpha
# Author: Nate Guagenti (@neu5ron)
# License: GPL-3.0
  
filter {
  if [event_type] == "zeek" and [event_sub_type] == "http" {

    mutate {
      rename => {
        "client_header_names" => "http_request_header_names"
        "client_headers" => "http_request_header_names"
        "cookie_vars" => "http_cookie_variables"
        "flash_version" => "software_flash_version_original"
        "host" => "http_request_header_host"
        "info_code" => "http_informational_code"
        "info_msg" => "http_informational_message"
        "method" => "http_request_method"
        "omniture" => "zeek_http_omniture"
        "orig_filenames" => "src_file_name"
        "orig_mime_types" => "src_mime_type"
        "origin" => "http_request_header_origin"
        "password" => "user_password"
        "post_body" => "http_response_body_original"
        "proxied" => "http_proxied_headers"
        "referrer" => "http_referrer_original"
        "request_body_len" => "http_request_body_bytes"
        "resp_filenames" => "file_name"
        "resp_mime_types" => "file_mime_type"
        "response_body_len" => "http_response_body_bytes"
        "server_header_names" => "http_response_header_names"
        "status_code" => "http_status_code"
        "status_msg" => "http_status_message"
        "tags" => "zeek_http_tags"
        "trans_depth" => "zeek_http_trans_depth"
        "uri" => "url_original"
        "uri_vars" => "url_query_values"
        "user_agent" => "user_agent_original"
        "username" => "user_name"
        "version" => "http_version"
      }
      add_field => { "etl_pipeline" => "zeek-http-main" }
    }

    ## Get unique request/original/client mime types
    #if [http_req_mime_type] {
    #  ruby {
    #    code => "
    #      http_req_mime_type = event.get('http_req_mime_type')
    #      http_req_mime_type = http_req_mime_type.map{|i| i.downcase}.uniq
    #      event.set('http_req_mime_type', http_req_mime_type)
    #    "
    #    add_field => { "z_logstash_pipeline" => "ruby-2401-001" }
    #    id => "ruby-2401-001"
    #    tag_on_exception =>  "_rubyexception_2401_1"
    #  }
    #}

    # Get unique response/server mime types
    #if [http_resp_mime_type] {
    #  ruby {
    #    code => "
    #      http_resp_mime_type = event.get('http_resp_mime_type')
    #      http_resp_mime_type = http_resp_mime_type.map{|i| i.downcase}.uniq
    #      event.set('http_resp_mime_type', http_resp_mime_type)
    #    "
    #    add_field => { "z_logstash_pipeline" => "ruby-2401-002" }
    #    id => "ruby-2401-002"
    #    tag_on_exception =>  "_rubyexception_2401_2"
    #  }
    #}

  }
}